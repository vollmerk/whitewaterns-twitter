#!/usr/bin/env python
# vim: set softtabstop=2 ts=2 sw=2 expandtab: 
#
# Copyright (c) 2015 Karl Vollmer (karl.vollmer@gmail.com)
#

import os,subprocess,sys,time
import ConfigParser
import json
import twitter
import tinyurl
import sqlite3
from datetime import datetime
from tzlocal import get_localzone

def sendTweet(tweetText):
  """ Send a tweet """
  try: 
    api = twitter.Api(consumer_key=Config.get('twitter','consumer_key'),
      consumer_secret=Config.get('twitter','consumer_secret'),
      access_token_key=Config.get('twitter','access_token'),
      access_token_secret=Config.get('twitter','access_token_secret'))
  except:
    print 'Unable to connect to Twitter please verify your API credentials'
    return False

  try:
    api.PostUpdate(tweetText)
    print 'Tweeted %s to your account' % (tweetText)
    return True
  except:
    print 'Unable to send %s to twitter, tweet failure' % (tweetText)
    return False


def runCmd(cmd):
  """ Run the command, and then wait for it to finish """
  proc = subprocess.Popen(cmd.split(),stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
  proc.wait()

  if proc.returncode != 0:
    print 'Non-zero exit from %s ' % (cmd)
    return ''
  else:
    return proc.stdout.read()

def saveState(name,state,level):
  """ Save the current state to a file in ./state """
  timestamp = int(time.time())
  stateHandle = open(os.path.dirname(os.path.abspath(__file__)) + '/state/'+name,'w')
  stateHandle.write(json.dumps({'state':state,'lastTweet':timestamp,'level':level}))
  stateHandle.close()
  return True

def saveStatetoDB(name,state,run,level):
  """ For now don't save things, not sure what I want to do with this data... """
  return True
  """ Get the Now time """
  now = datetime.now(get_localzone())

  dbh = sqlite3.connect(os.path.dirname(os.path.abspath(__file__)) + '/' + Config.get('sql','database_name'))
  dbcursor = dbh.cursor()
  dbcursor.execute('''CREATE TABLE IF NOT EXISTS levels (date text,name text,run text,state text,level real)''')
  dbcursor.execute('INSERT INTO levels VALUES (?,?,?,?,?)',[now.isoformat('T'),name,state,run,level])
  dbh.commit()
  dbh.close()
  return True


def checkLevels():
  sourceHandle = open(os.path.dirname(os.path.abspath(__file__)) + '/source.json')
  data = sourceHandle.read()
  sources = json.loads(data)
  for row in sources:
    cmd = os.path.dirname(os.path.abspath(__file__)) + '/bin/' + row['type'] + ' ' + row['source']
    cmdResults = runCmd(cmd)
    if len(cmdResults) == 0:
      """ If nothing returned jump to the next source """
      continue
    else:
      currentState = json.loads(cmdResults)

    """ Now we need to figure out if we need to tweet something """
    for level in row['level']:
      stateName = row['uid']+level['name']
      """ Look for a previous state file """
      if os.path.exists(os.path.dirname(os.path.abspath(__file__)) + '/state/' + stateName):
        previousState = json.loads(open(os.path.dirname(os.path.abspath(__file__)) + '/state/' + stateName).read())
      else:
        previousState = { 'state':'down','lastTweet':int('0') }

      """ Look at the current level, and update the the database """
      if float(currentState['level']) < float(level['min']):
        saveStatetoDB(row['uid'],'down',level['name'],currentState['level'])
      elif float(currentState['level']) >= float(level['max']):
        saveStatetoDB(row['uid'],'flood',level['name'],currentState['level'])
      elif float(currentState['level']) >= float(level['min']) and float(currentState['level']) < float(level['max']):
        saveStatetoDB(row['uid'],'up',level['name'],currentState['level'])

      """ See if we should tweet out a change in this level """
      if float(currentState['level']) >= float(level['min']) and float(currentState['level']) <= float(level['max']):
        if previousState['state'] == 'down': 
          sendTweet('%s (%s) is up! Current Level %s' % (row['name'],level['name'],currentState['level']))
          saveState(stateName,'up',currentState['level'])
        elif (int(previousState['lastTweet'])+172800) <= int(time.time()):
          sendTweet('%s (%s) is still up, it\'s at %s' % (row['name'],level['name'],currentState['level']))
          saveState(stateName,'up',currentState['level'])
      elif float(currentState['level']) >= float(level['max']) and previousState['state'] == 'up':
        sendTweet('%s (%s) is in Flood, current level is %s' % (row['name'],level['name'],currentState['level']))
        saveState(stateName,'down',currentState['level'])
      elif previousState['state'] == 'up':
        sendTweet('%s (%s) is down Current Level %s' % (row['name'],level['name'],currentState['level']))
        saveState(stateName,'down',currentState['level'])



if __name__ == '__main__':
  global Config
  """ Load the Config file ./settings.conf """
  Config = ConfigParser.ConfigParser()
  try:
    Config.read(os.path.dirname(os.path.abspath(__file__)) + '/settings.conf')
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (os.path.dirname(os.path.abspath(__file__)) + '/settings.conf')
    sys.exit(1)
  checkLevels()

