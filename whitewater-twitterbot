#!/usr/bin/env python
# vim: set softtabstop=2 ts=2 sw=2 expandtab: 
#
# Copyright (c) 2015 Karl Vollmer (karl.vollmer@gmail.com)
#

import os,subprocess,sys,time,shutil
import ConfigParser
import json
import twitter
import tinyurl
import sqlite3
from datetime import datetime
from tzlocal import get_localzone

def sendTweet(tweetText):
  """ Send a tweet """
  try: 
    api = twitter.Api(consumer_key=Config.get('twitter','consumer_key'),
      consumer_secret=Config.get('twitter','consumer_secret'),
      access_token_key=Config.get('twitter','access_token'),
      access_token_secret=Config.get('twitter','access_token_secret'))
  except:
    print 'Unable to connect to Twitter please verify your API credentials'
    return False

  try:
    api.PostUpdate(tweetText)
    print 'Tweeted %s to your account' % (tweetText)
    return True
  except:
    print 'Unable to send %s to twitter, tweet failure' % (tweetText)
    return False

def sendSurfTweet(tweetText):
  """ Send a tweet """
  try: 
    api = twitter.Api(consumer_key=Config.get('surftwitter','consumer_key'),
      consumer_secret=Config.get('surftwitter','consumer_secret'),
      access_token_key=Config.get('surftwitter','access_token'),
      access_token_secret=Config.get('surftwitter','access_token_secret'))
  except:
    print 'Unable to connect to Twitter please verify your API credentials'
    return False

  try:
    api.PostUpdate(tweetText)
    print 'Tweeted %s to your account' % (tweetText)
    return True
  except:
    print 'Unable to send %s to twitter, tweet failure' % (tweetText)
    return False


def runCmd(cmd):
  """ Run the command, and then wait for it to finish """
  proc = subprocess.Popen(cmd.split(),stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
  proc.wait()

  if proc.returncode != 0:
    print 'Non-zero exit from %s ' % (cmd)
    return ''
  else:
    return proc.stdout.read()

def saveState(name,state,level):
  """ Save the current state to a file in ./state """
  timestamp = int(time.time())
  stateHandle = open(os.path.dirname(os.path.abspath(__file__)) + '/state/'+name,'w')
  stateHandle.write(json.dumps({'state':state,'lastTweet':timestamp,'level':level}))
  stateHandle.close()
  return True

def saveStatetoDB(name,state,run,level):
  """ For now don't save things, not sure what I want to do with this data... """
  return True
  """ Get the Now time """
  now = datetime.now(get_localzone())

  dbh = sqlite3.connect(os.path.dirname(os.path.abspath(__file__)) + '/' + Config.get('sql','database_name'))
  dbcursor = dbh.cursor()
  dbcursor.execute('''CREATE TABLE IF NOT EXISTS levels (date text,name text,run text,state text,level real)''')
  dbcursor.execute('INSERT INTO levels VALUES (?,?,?,?,?)',[now.isoformat('T'),name,state,run,level])
  dbh.commit()
  dbh.close()
  return True

def saveStatetoImage(name,state,run,level):

  """ just Copy some files man this ain't rocket science """
  """ FIXME: should use same extension as source, but really you should be using png """
  target = Config.get('dashboard','target_dir') + '/' + name.replace(' ','') + run.replace(' ','') + '.png'
  source = Config.get('dashboard',state + '_image')
  try:
    shutil.copyfile(source,target)
  except:
    print 'Unable to copy %s to %s bummer' % (source,target)

  return True

""" Based on the Type, run whatever checks we should be running to determine if this is "UP" """
def isUp(state,sourceType,level):

  """ Rules:
    - Above Min
    - Below Max
  """
  if sourceType == 'river':
    if state['level'] < level['max'] and state['level'] >= level['min']:
      return True

  """ Rules:
    - Above min
    - Below max
    - Period is higher than min
    - Between Min & Max direction
    - Between min & max tide point
    - Between min & max wind from Direction A-Z
  """
  elif sourceType == 'surf':
    if (state['level'] < level['max'] and state['level'] >= level['min'] and
        state['direction'] < level['dirmax'] and state['direction'] >= level['dirmin'] and
        state['period'] > level['permin']):
      return True

  """ Rules:
    - Above Min
    - Below Max
    - Between min & max tide point
  """
  elif sourceType == 'tidal':
    return False

  return False

def isFlood(state,sourceType,level):

  if sourceType == 'river':
    if state['level'] >= level['max']: 
      return True

  """ Rules:
    - too big of waves
    - bad direction
    - waves above min, but period below min
  """
  elif sourceType == 'surf':
    if (state['level'] >= level['max'] or state['direction'] < level['dirmin'] or state['direction'] > level ['dirmax'] or
        (state['level'] >= level['min'] and state['period'] < level['permin'])):
      return True

  return False

def isDown(state,sourceType,level):

  return False

def tweetMsg(name,location,data,state,sourceType):
  twitterText = ''

  if sourceType == 'river':
    if state == 'up':
      twitterText = '%s (%s) is up! Current Level %s' % (name,location,data['level'])
    elif state == 'down':
      twitterText = '%s (%s) is down, Current Level %s' % (name,location,data['level'])
    elif state == 'flood':
      twitterText = '%s (%s) is in flood, Current Level %s' % (name,location,data['level'])
  elif sourceType == 'surf':
    if state == 'up':
      twitterText = '%s is working, %s%s' % (location,data['level'],data['level_info'])

  return twitterText

def checkLevels():
  sourceHandle = open(os.path.dirname(os.path.abspath(__file__)) + '/source.json')
  data = sourceHandle.read()
  sources = json.loads(data)
  for row in sources:
    cmd = os.path.dirname(os.path.abspath(__file__)) + '/bin/' + row['type'] + ' ' + row['source']
    cmdResults = runCmd(cmd)
    if len(cmdResults) == 0:
      """ If nothing returned jump to the next source """
      continue
    else:
      currentState = json.loads(cmdResults)

    """ Set default type to river if not defined """
    if 'level_type' in currentState:
      levelType = currentState['level_type']
    else:
      levelType = 'river'


    """ Now we need to figure out if we need to tweet something """
    for level in row['level']:
      stateName = row['uid']+level['name']
      """ Look for a previous state file """
      if os.path.exists(os.path.dirname(os.path.abspath(__file__)) + '/state/' + stateName):
        previousState = json.loads(open(os.path.dirname(os.path.abspath(__file__)) + '/state/' + stateName).read())
      else:
        previousState = { 'state':'down','lastTweet':int('0') }

      """ Rivers, Tides and Surf all have different conditionals for Up/down let's use a function """
      if levelType == 'river':

        """ Look at the current level, and update the the database """
        if float(currentState['level']) < float(level['min']):
          saveStatetoDB(row['uid'],'down',level['name'],currentState['level'])
          saveStatetoImage(row['uid'],'down',level['name'],currentState['level'])
        elif float(currentState['level']) >= float(level['max']):
          saveStatetoDB(row['uid'],'flood',level['name'],currentState['level'])
          saveStatetoImage(row['uid'],'flood',level['name'],currentState['level'])
        elif float(currentState['level']) >= float(level['min']) and float(currentState['level']) < float(level['max']):
          saveStatetoDB(row['uid'],'up',level['name'],currentState['level'])
          saveStatetoImage(row['uid'],'up',level['name'],currentState['level'])
  
        """ See if we should tweet out a change in this level """
        if float(currentState['level']) >= float(level['min']) and float(currentState['level']) <= float(level['max']):
          if previousState['state'] == 'down':
            sendTweet('%s (%s) is up! Current Level %s' % (row['name'],level['name'],currentState['level']))
            saveState(stateName,'up',currentState['level'])
          elif (int(previousState['lastTweet'])+172800) <= int(time.time()):
            sendTweet('%s (%s) is still up, it\'s at %s' % (row['name'],level['name'],currentState['level']))
            saveState(stateName,'up',currentState['level'])
        elif float(currentState['level']) >= float(level['max']) and previousState['state'] == 'up':
          sendTweet('%s (%s) is in Flood, current level is %s' % (row['name'],level['name'],currentState['level']))
          saveState(stateName,'down',currentState['level'])
        elif previousState['state'] == 'up':
          sendTweet('%s (%s) is down Current Level %s' % (row['name'],level['name'],currentState['level']))
          saveState(stateName,'down',currentState['level'])

      elif levelType == 'surf':

        """ Up is min/max + dirmin/dirmax """
        if float(currentState['level']) >= float(level['min']) and float(currentState['level']) < float(level['max']) and float(currentState['direction']) >= float(level['dirmin']) and float(currentState['direction']) <= float(level['dirmax']):
          if previousState['state'] == 'down':
            sendTweet('%s (%s) is up! %s%s' % (row['name'],level['name'],currentState['level'],currentState['level_info']))
            sendSurfTweet('%s is up! %s%s' % (level['name'],currentState['level'],currentState['level_info']))
            saveState(stateName,'up',currentState['level'])
            saveStatetoImage(row['uid'],'up',level['name'],currentState['level'])
          elif (int(previousState['lastTweet'])+172800) <= int(time.time()):
            sendTweet('%s (%s) is still up! %s%s' % (row['name'],level['name'],currentState['level'],currentState['level_info']))
            sendSurfTweet('%s is still up! %s%s' % (level['name'],currentState['level'],currentState['level_info']))
            saveState(stateName,'up',currentState['level'])
        elif (float(currentState['level']) >= float(level['max'])) or float(currentState['direction'] > float(level['dirmax']) or float(currentState['direction']) < float(level['dirmin'])):
            if previousState['state'] != 'flood':
              sendTweet('%s (%s) is not ideal %s%s' % (row['name'],level['name'],currentState['level'],currentState['level_info'])) 
              sendSurfTweet('%s is not ideal %s%s' % (level['name'],currentState['level'],currentState['level_info'])) 
              saveState(stateName,'flood',currentState['level'])
              saveStatetoImage(row['uid'],'flood',level['name'],currentState['level'])
            elif (int(previousState['lastTweet'])+172800) <= int(time.time()):
              sendTweet('%s (%s) is not ideal %s%s' % (row['name'],level['name'],currentState['level'],currentState['level_info']))
              sendSurfTweet('%s is not ideal %s%s' % (level['name'],currentState['level'],currentState['level_info']))
              saveState(stateName,'flood',currentState['level'])
        elif previousState['state'] == 'up' or previousState['state'] == 'flood':
            sendTweet('%s (%s) is down %s%s' % (row['name'],level['name'],currentState['level'],currentState['level_info']))
            sendSurfTweet('%s is down %s%s' % (level['name'],currentState['level'],currentState['level_info']))
            saveState(stateName,'down',currentState['level'])
            saveStatetoImage(row['uid'],'down',level['name'],currentState['level'])

if __name__ == '__main__':
  global Config
  """ Load the Config file ./settings.conf """
  Config = ConfigParser.ConfigParser()
  try:
    Config.read(os.path.dirname(os.path.abspath(__file__)) + '/settings.conf')
  except IOError:
    print ':Main:: IOError opening %s verify permissions' % (os.path.dirname(os.path.abspath(__file__)) + '/settings.conf')
    sys.exit(1)
  checkLevels()

